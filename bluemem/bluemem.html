<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BLUE MEMORY — PNG Version (v2.1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#0b1220; color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans"; }
    canvas { display:block; width:100vw; height:100vh; outline:none; }
  </style>
</head>
<body>
<canvas id="game" tabindex="0" aria-label="BLUE MEMORY — PNG Version"></canvas>
<script>
(function(){
  'use strict';
  const W=1280,H=720;
  const THEME={BG:"#0b1220",Y:"#f2c32f",EDGE:"#2b3d5f",CARD:"#16243c",TEXT:"rgba(230,240,255,0.95)",RED:"#ff5d5d"};
  const PHASES = [
  {cols:4,rows:4,pairs:8,label:"Phase 1"},
  {cols:4,rows:4,pairs:8,label:"Phase 2"},
  {cols:4,rows:4,pairs:8,label:"Phase 3"},
  {cols:4,rows:4,pairs:8,label:"Phase 4"},
  {cols:4,rows:4,pairs:8,label:"Phase 5"},
  {cols:4,rows:4,pairs:8,label:"Phase 6"},
  {cols:4,rows:4,pairs:8,label:"Phase 7"},
  {cols:4,rows:4,pairs:8,label:"Phase 8"}
];
  const ZONE_RATES=[1,1.5,2.5,4,5.5,7,10,16]; // HP/sec
  const LS_STATS='blue.memory.stats.v21';

  function loadStats(){try{const s=localStorage.getItem(LS_STATS);return s?JSON.parse(s):{best:Array(9).fill(null)};}catch(e){return {best:Array(9).fill(null)};}}
  function saveStats(o){try{localStorage.setItem(LS_STATS,JSON.stringify(o))}catch(e){}}

  const IMG_CACHE={};
  function loadImage(src){
    return new Promise(resolve=>{
      if(IMG_CACHE[src]!==undefined){ resolve(IMG_CACHE[src]); return; }
      const im=new Image(); im.onload=()=>{IMG_CACHE[src]=im; resolve(im)}; im.onerror=()=>{IMG_CACHE[src]=null; resolve(null)}; im.src=src;
    });
  }
  function drawImageContain(img, x,y,w,h, pad, radius){
    if(!img){ return false; }
    const iw=img.naturalWidth, ih=img.naturalHeight; if(!iw||!ih) return false;
    const innerW=w-pad*2, innerH=h-pad*2;
    const r=Math.min(innerW/iw, innerH/ih);
    const nw=iw*r, nh=ih*r;
    const cx=x+pad+(innerW-nw)/2, cy=y+pad+(innerH-nh)/2;
    ctx.save();
    roundedPath(x+2, y+2, w-4, h-4, Math.min(radius, (w-4)/2, (h-4)/2));
    ctx.clip();
    try{ ctx.drawImage(img, cx, cy, nw, nh); }catch(e){ ctx.restore(); return false; }
    ctx.restore();
    return true;
  }

  const canvas=document.getElementById("game");
  const ctx=canvas.getContext("2d");
  function resize(){const dpr=Math.max(1,window.devicePixelRatio||1); canvas.width=Math.round(window.innerWidth*dpr); canvas.height=Math.round(window.innerHeight*dpr); ctx.setTransform(canvas.width/W,0,0,canvas.height/H,0,0);}
  window.addEventListener("resize",resize,{passive:true});

  const stats = loadStats();
  // --- FIX: Ensure stats.best always has correct structure ---
  if (!stats.best || !Array.isArray(stats.best) || stats.best.length < 9) {
    stats.best = Array(9).fill(null);
    saveStats(stats);
  }

  const state = {
    phase:1, deck:[], first:null, second:null, lock:false,
    moves:0, matches:0,
    hp:100, hpAnim:100, hpFlash:null,
    pulse:0, mode:"play",
    banner:null, bannerT:0,
    blueActive:false, blueTimer:0, blueRate:1,
    phaseIntro:true, phaseIntroT:0,
    loading:true, loadMsg:"Loading cards...", imagesReady:false
  };

  function shuf(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a;}
  function newDeck(nPairs){
    const d=[]; let id=0;
    for(let k=1;k<=nPairs;k++){ d.push({id:id++,idx:k,open:false,matched:false,flip:0}); d.push({id:id++,idx:k,open:false,matched:false,flip:0}); }
    return shuf(d);
  }
  function phaseImageList(pairs, phase){
    const arr=["card-back.png"];
    for(let k=1;k<=pairs;k++){ arr.push("P"+phase+"-C"+k+".png"); }
    return arr;
  }

  function startPhase(p){
    const P=PHASES[p-1]||PHASES[0];
    state.phase=p; state.deck=newDeck(P.pairs);
    state.first=state.second=null; state.lock=false;
    state.moves=0; state.matches=0;
    state.mode="play"; state.banner=null; state.bannerT=0;
    state.phaseIntro=true; state.phaseIntroT=0;
    state.blueRate=ZONE_RATES[p-1]||1;
    state.loading=true; state.imagesReady=false; state.loadMsg="Loading cards...";
    const imgs=phaseImageList(P.pairs, p);
    Promise.all(imgs.map(loadImage)).then(()=>{
      state.imagesReady=true;
      if(p===1){ state.blueActive=false; state.blueTimer=10; } else { state.blueActive=true; state.blueTimer=0; }
      state.loading=false;
    });
  }
  function nextPhase(){
    if(state.phase<8){ state.banner="phase"; state.bannerT=0; setTimeout(()=>startPhase(state.phase+1),900); }
    else { state.mode="winner"; state.banner="winner"; state.bannerT=0; }
  }
  function heal(a){ state.hp=Math.min(100,state.hp+a); state.hpFlash="heal"; }
  function damage(a){ state.hp=Math.max(0,state.hp-a); state.hpFlash="hurt"; if(state.hp<=0){ state.mode="knocked"; state.banner="knocked"; state.bannerT=0; } }

  function layout(){
    const P=PHASES[state.phase-1], cols=P.cols, rows=P.rows;
    const gx=64, gy=150, gw=W-360, gh=H-270, g=12;
    const cw=(gw-g*(cols-1))/cols, ch=(gh-g*(rows-1))/rows, arr=[];
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) arr.push({x:gx+c*(cw+g), y:gy+r*(ch+g), w:cw, h:ch});
    return arr;
  }
  function inR(mx,my,b){return mx>=b.x && mx<=b.x+b.w && my>=b.y && my<=b.y+b.h;}
  function cardAt(mx,my){const L=layout(); for(let i=0;i<state.deck.length;i++){ if(inR(mx,my,L[i])) return i; } return -1;}

  const mouse={x:0,y:0,clicked:false};
  function toCanvas(e){const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height)};}
  canvas.addEventListener("mousemove",e=>{const p=toCanvas(e); mouse.x=p.x; mouse.y=p.y;});
  canvas.addEventListener("mousedown",()=>{mouse.clicked=true; canvas.focus();});
  window.addEventListener("keydown",e=>{
    if(e.key==="Escape"){ state.hp=100; state.hpAnim=100; startPhase(1); return; }
    if(state.mode!=="play"){
      if(e.key==="Enter"||e.key===" "){
        if(state.mode==="winner"||state.mode==="knocked"){ state.hp=100; state.hpAnim=100; startPhase(1); }
        else startPhase(state.phase);
      }
    }
  });

  function onClick(i){
    if(i<0) return;
    const c=state.deck[i];
    if(state.lock||c.matched||c.open) return;
    c.open=true;
    if(state.first===null) state.first=i;
    else if(state.second===null){
      state.second=i; state.lock=true; state.moves++;
      setTimeout(resolvePick,420);
    }
  }
  function resolvePick(){
    const a=state.deck[state.first], b=state.deck[state.second];
    if(a&&b){
      if(a.idx===b.idx){
        a.matched=b.matched=true;
        state.matches++;
        heal(5);
        if(state.matches===PHASES[state.phase-1].pairs){
          const ph=state.phase; const prev=stats.best[ph];
          if(prev===null || state.moves<prev){stats.best[ph]=state.moves; saveStats(stats);}
          if(state.hp>0){ state.mode="win"; state.banner="phase"; state.bannerT=0; setTimeout(nextPhase,800); }
        }
      } else { a.open=false; b.open=false; }
    }
    state.first=state.second=null; state.lock=false;
  }

  // (rest of your code unchanged)
  // ... all the rendering, banners, HP, etc. remain identical ...
  // This snippet only changes the stats safety section near the top.
})();
</script>

</body>
</html>
